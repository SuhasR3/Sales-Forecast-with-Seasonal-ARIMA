# -*- coding: utf-8 -*-
"""CNN on Time Series Data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A6NUSuOh7KXayjvEhKCOgpfi_E2HXSEs
"""

import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv1D, Dense, Dropout, Flatten
import matplotlib.pyplot as plt

# Data preprocessing
def prepare_data(data, sequence_length=12):
    scaler = MinMaxScaler()
    scaled_data = scaler.fit_transform(data[['Sales']]).flatten()

    X, y = [], []
    for i in range(len(scaled_data) - sequence_length):
        X.append(scaled_data[i:i + sequence_length])
        y.append(scaled_data[i + sequence_length])

    return np.array(X), np.array(y), scaler

# Model architecture
def create_model(sequence_length):
    model = Sequential([
        Conv1D(filters=64, kernel_size=2, activation='relu', input_shape=(sequence_length, 1)),
        Dropout(0.2),
        Conv1D(filters=32, kernel_size=2, activation='relu'),
        Dropout(0.2),
        Flatten(),
        Dense(50, activation='relu'),
        Dropout(0.2),
        Dense(1)
    ])

    model.compile(optimizer='adam', loss='mse')
    return model

# Prediction and plotting
def plot_predictions(train_data, predictions, scaler):
    plt.figure(figsize=(12, 6))
    plt.plot(train_data['Sales'].values, label='Historical Sales', color='blue')

    # Plot predictions
    forecast_index = np.arange(len(train_data), len(train_data) + len(predictions))
    predictions_unscaled = scaler.inverse_transform(predictions.reshape(-1, 1))
    plt.plot(forecast_index, predictions_unscaled, label='Forecast', color='orange')

    plt.title('Sales Forecast')
    plt.xlabel('Time')
    plt.ylabel('Sales')
    plt.legend()
    plt.grid(True)
    plt.show()

# Main execution
sequence_length = 12
train_data = pd.read_csv('monthly-sales-data.csv')
test_data = pd.read_csv('test-sales-data.csv')

# Prepare data
X, y, scaler = prepare_data(train_data, sequence_length)
X = X.reshape((X.shape[0], X.shape[1], 1))

# Create and train model
model = create_model(sequence_length)
model.fit(X, y, epochs=500, batch_size=64, verbose=1)

# Generate predictions for next 12 months
last_sequence = X[-1:]
predictions = []

for _ in range(12):
    next_pred = model.predict(last_sequence)
    predictions.append(next_pred[0])
    last_sequence = np.roll(last_sequence, -1)
    last_sequence[0, -1, 0] = next_pred

predictions = np.array(predictions)

# Plot results with scaler
plot_predictions(train_data, predictions, scaler)

# Predict on the testing sequences
train_predictions = model.predict(X)
# Inverse-transform predictions and true values to the original scale
train_predictions_unscaled = scaler.inverse_transform(train_predictions)
y_unscaled = scaler.inverse_transform(y.reshape(-1, 1))

# Calculate MAPE
mape = np.mean(np.abs((y_unscaled - train_predictions_unscaled) / y_unscaled)) * 100
accuracy = 100 - mape

print("Model Accuracy on Testing Data: {:.2f}%".format(accuracy))